"""Builtin plugin for providing pricing functionality."""

from django.core.validators import MinValueValidator
from django.utils.translation import gettext_lazy as _

import structlog
from djmoney.money import Money

import order.models as order_models
import order.status_codes as order_status_codes
from common.currency import convert_currency
from common.pricing import PriceRangeTuple
from plugin import InvenTreePlugin
from plugin.mixins import PricingMixin, SettingsMixin

logger = structlog.get_logger('inventree')


class InvenTreePricingPlugin(PricingMixin, SettingsMixin, InvenTreePlugin):
    """Default InvenTree plugin for pricing functionality."""

    NAME = 'InvenTreePricingPlugin'
    SLUG = 'inventree-pricing'
    AUTHOR = _('InvenTree contributors')
    TITLE = _('InvenTree Pricing Plugin')
    DESCRIPTION = _('Provides default pricing integration functionality for InvenTree')
    VERSION = '1.0.0'

    # Plugin settings which can be configured to adjust pricing behavior
    SETTINGS = {
        'PRICING_USE_SUPPLIER_PRICING': {
            'name': _('Use Supplier Pricing'),
            'description': _(
                'Include supplier price breaks in overall pricing calculations'
            ),
            'default': True,
            'validator': bool,
        },
        'PRICING_PURCHASE_HISTORY_OVERRIDES_SUPPLIER': {
            'name': _('Purchase History Override'),
            'description': _(
                'Historical purchase order pricing overrides supplier price breaks'
            ),
            'default': False,
            'validator': bool,
        },
        'PRICING_USE_STOCK_PRICING': {
            'name': _('Use Stock Item Pricing'),
            'description': _(
                'Use pricing from manually entered stock data for pricing calculations'
            ),
            'default': True,
            'validator': bool,
        },
        'PRICING_STOCK_ITEM_AGE_DAYS': {
            'name': _('Stock Item Pricing Age'),
            'description': _(
                'Exclude stock items older than this number of days from pricing calculations'
            ),
            'default': 0,
            'units': _('days'),
            'validator': [int, MinValueValidator(0)],
        },
        'PRICING_USE_VARIANT_PRICING': {
            'name': _('Use Variant Pricing'),
            'description': _('Include variant pricing in overall pricing calculations'),
            'default': True,
            'validator': bool,
        },
        'PRICING_ACTIVE_VARIANTS': {
            'name': _('Active Variants Only'),
            'description': _(
                'Only use active variant parts for calculating variant pricing'
            ),
            'default': True,
            'validator': bool,
        },
        'PRICING_USE_INTERNAL_PRICE': {
            'name': _('Internal Price Override'),
            'description': _(
                'If available, internal prices override price range calculations'
            ),
            'default': False,
            'validator': bool,
        },
    }

    def calculate_part_overall_price_range(
        self, part, *args, **kwargs
    ) -> PriceRangeTuple:
        """Calculate the overall price for a given part.

        Arguments:
            part: The part instance for which to calculate the price.
            *args, **kwargs: Additional arguments for price calculation.

        Returns:
            A tuple representing the min, max price range for the part

        The default implementation calculates the price range based on
        the overall price range generated by the part's pricing data.
        """

    def calculate_part_bom_price_range(self, part, *args, **kwargs) -> PriceRangeTuple:
        """Calculate the assembly price range for a given part.

        Arguments:
            part: The part instance for which to calculate the BOM price.
            *args, **kwargs: Additional arguments for BOM price calculation.

        Returns:
            A tuple representing the min, max BOM price range for the part

        The "BOM price range" is the cost of manufacturing the assembly
        from its constituent parts, based on their pricing data.
        """

    def calculate_part_purchase_price_range(
        self, part, *args, **kwargs
    ) -> PriceRangeTuple:
        """Calculate the purchase price range for a given part.

        Arguments:
            part: The part instance for which to calculate the purchase price.
            *args, **kwargs: Additional arguments for purchase price calculation.

        Returns:
            A tuple representing the min, max purchase price range for the part

        The "purchase price range" is the cost to purchase the part from suppliers,
        """
        # Find all line items for completed PurchaseOrders which reference this part
        line_items = order_models.PurchaseOrderLineItem.objects.filter(
            order__status__in=order_status_codes.PurchaseOrderStatusGroups.COMPLETE,
            received__gt=0,
            part__part=part,
        )

        # Exclude line items which do not have an associated price
        line_items = line_items.exclude(purchase_price=None)

        line_items = line_items.prefetch_related('part', 'part__part')

        purchase_min: Money = None
        purchase_max: Money = None

        # Iterate through all line items to determine min/max purchase price
        for line in line_items:
            if line.purchase_price is None:
                continue

            # Account for supplier part pack size
            purchase_cost = convert_currency(
                line.purchase_price / line.part.pack_quantity_native
            )

            if purchase_cost is None:
                continue

            if purchase_min is None or purchase_cost < purchase_min:
                purchase_min = purchase_cost

            if purchase_max is None or purchase_cost > purchase_max:
                purchase_max = purchase_cost

        return PriceRangeTuple(min=purchase_min, max=purchase_max)

    def calculate_part_supplier_price_range(
        self, part, *args, **kwargs
    ) -> PriceRangeTuple:
        """Calculate the supplier price range for a given part.

        Arguments:
            part: The part instance for which to calculate the supplier price.
            *args, **kwargs: Additional arguments for supplier price calculation.

        Returns:
            A tuple representing the min, max supplier price range for the part
        """
        price_min: Money = None
        price_max: Money = None

        # Ignore if the part is not marked as purchaseable
        if not part.purchaseable:
            return PriceRangeTuple(min=price_min, max=price_max)

        # Fetch supplier parts for this part
        supplier_parts = part.supplier_parts.filter(active=True).prefetch_related(
            'pricebreaks'
        )

        # Iterate through each active supplier part
        for supplier_part in supplier_parts.all():
            # Iterate through each price break for this supplier part
            for price_break in supplier_part.pricebreaks.all():
                if price_break.price is None:
                    continue

                # Ensure that the supplier part pack size is taken into account
                price = convert_currency(
                    price_break.price / supplier_part.pack_quantity_native
                )

                if price is None:
                    continue

                if price_min is None or price < price_min:
                    price_min = price

                if price_max is None or price > price_max:
                    price_max = price

        return PriceRangeTuple(min=price_min, max=price_max)

    def calculate_part_internal_price_range(
        self, part, *args, **kwargs
    ) -> PriceRangeTuple:
        """Calculate the internal price range for a given part.

        Arguments:
            part: The part instance for which to calculate the internal price.
            *args, **kwargs: Additional arguments for internal price calculation.

        Returns:
            A tuple representing the min, max internal price range for the part
        """
        min_price: Money = None
        max_price: Money = None

        for pb in self.part.internalpricebreaks.all():
            if pb.price is None:
                continue

            cost = convert_currency(pb.price)

            if cost is None:
                # Ignore if cost could not be converted for some reason
                continue

            if min_price is None or cost < min_price:
                min_price = cost

            if max_price is None or cost > max_price:
                max_price = cost

        return PriceRangeTuple(min=min_price, max=max_price)

    def calculate_part_variant_price_range(
        self, part, *args, **kwargs
    ) -> PriceRangeTuple:
        """Calculate the variant price range for a given part.

        Arguments:
            part: The part instance for which to calculate the variant price.
            *args, **kwargs: Additional arguments for variant price calculation.

        Returns:
            A tuple representing the min, max variant price range for the part

        The "variant price range" is the price range for all variants of a template part
        """
        variant_min: Money = None
        variant_max: Money = None

        # If the part is not a template, return immediately
        if not self.part.is_template:
            return PriceRangeTuple(min=variant_min, max=variant_max)

        active_only = self.get_setting('PRICING_ACTIVE_VARIANTS', backup_value=True)
        variants = part.get_descendants(include_self=False)

        variants = variants.prefetch_related('pricing')

        if active_only:
            variants = variants.filter(active=True)

        for variant in variants:
            v_min = convert_currency(variant.pricing.overall_min)
            v_max = convert_currency(variant.pricing.overall_max)

            if v_min is not None:
                if variant_min is None or v_min < variant_min:
                    variant_min = v_min

            if v_max is not None:
                if variant_max is None or v_max > variant_max:
                    variant_max = v_max

        return PriceRangeTuple(min=variant_min, max=variant_max)

    def calculate_part_sale_price_range(self, part, *args, **kwargs) -> PriceRangeTuple:
        """Calculate the sale price range for a given part.

        Arguments:
            part: The part instance for which to calculate the sale price.
            *args, **kwargs: Additional arguments for sale price calculation.

        Returns:
            A tuple representing the min, max sale price range for the part
        """
