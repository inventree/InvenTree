# Generated by Django 4.2.22 on 2025-07-01 13:34

from django.db import migrations


def template_hash(template):
    """Generate a 'hash' for a PartTestTemplate instance.
    
    This is used to identify similar templates that can be consolidated.

    To be eligable for consolidation, the template must be unique across:
    - key
    - enabled
    - required
    - requires_value
    - requires_attachment
    - choices
    """

    return f"{template.key}-{template.enabled}-{template.required}-{template.requires_value}-{template.requires_attachment}-{template.choices}"


def migrate_test_template(apps, schema_editor):
    """Migrate PartTestTemplate entries.

    - In migration 0136 we added a PartTest model, to replace the PartTestTemplate model
    - The PartTest will link either a Part or PartCategory to a PartTestTemplate
    - This migration will create PartTest entries for existing PartTestTemplate entries
    - It will also attemt to consolidate similar PartTestTemplate entries (where possible)
    """

    PartTestTemplate = apps.get_model('part', 'PartTestTemplate')
    PartTest = apps.get_model('part', 'PartTest')
    StockItemTestResult = apps.get_model('stock', 'StockItemTestResult')

    N_RESULTS = StockItemTestResult.objects.count()
    N_TEMPLATES = PartTestTemplate.objects.count()

    # Get all PartTestTemplate entries
    templates = PartTestTemplate.objects.all()

    if templates.count() == 0:
        return
    
    print(f"\nMigrating {templates.count()} PartTestTemplate entries.")

    template_map = dict()
    duplicate_count = 0

    for template in templates.all():
        # Each existing template links to a Part - we need to generate a new PartTest instance
        # print("-", template.key, '->', template_hash(template))
        key = template_hash(template)

        if matching_template := template_map.get(key):
            # We have found a duplicate template
            # Assign all the StockItemTestResult entries to the matching template
            results = StockItemTestResult.objects.filter(template=template)

            if results.exists():
                results.update(template=matching_template)
            
            # There should be no StockItemTestResult entries linked to the matching template!"
            assert StockItemTestResult.objects.filter(template=matching_template).count() == 0

            # Now that the results have been migrated, we can delete the old template
            template.delete()

            duplicate_count += 1
            continue

        # Create a new PartTest instance for this template
        PartTest.objects.create(
            template=template,
            part=template.part
        )

        template_map[key] = template

    N_PART_TEST = PartTest.objects.count()

    # The number of PartTest entries should match the number of unique PartTestTemplate entries
    assert N_PART_TEST + duplicate_count == N_TEMPLATES

    # The total number of results *MUST* not change
    assert StockItemTestResult.objects.count() == N_RESULTS

    print(f"- Created {PartTest.objects.count()} PartTest entries.")

    if duplicate_count > 0:
        print(f"- Removed {duplicate_count} duplicate PartTestTemplate entries.")


def reverse_migrate_test_template(apps, schema_editor):
    """Reverse migration for PartTestTemplate entries.

    For each PartTest, we must update the corresponding PartTestTemplate
    """
    
    PartTest = apps.get_model('part', 'PartTest')

    for test in PartTest.objects.all():
        template = test.tempate
        template.part = test.part
        template.save()


class Migration(migrations.Migration):

    dependencies = [
        ("part", "0136_parttest"),
    ]

    operations = [
        migrations.RunPython(
            migrate_test_template,
            reverse_code=reverse_migrate_test_template
        )
    ]
